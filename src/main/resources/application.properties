# --- Application Metadata ---

# Sets the internal name of this microservice; used by service discovery (like Eureka) and in log patterns.
spring.application.name=iam-service


# --- Server Configuration ---

# Defines the TCP port the embedded web server (Tomcat/Netty) will listen on for incoming requests.
server.port=8080

# Forces Spring to include the specific error message (e.g., "User not found") in the JSON response body.
# Note: 'server.error.include-message' is now deprecated in favor of this property.
spring.web.error.include-message=always


# --- Logging Configuration ---

# Sets the log level for the Spring Framework itself to INFO, so you only see major events and startup logs.
logging.level.org.springframework=INFO

# Enables detailed DEBUG logging for your own code (pl.jakubsiekiera.iam) to help trace logic and fix bugs.
logging.level.pl.jakubsiekiera.iam=DEBUG


# --- Docker Compose Support ---

# Since 'spring-boot-docker-compose' is in the pom.xml, Spring automatically finds the DB.
# We explicitly tell it to use the 'postgres' service to avoid ambiguity with Keycloak.
spring.docker.compose.enabled=true
spring.docker.compose.service.connection.name=postgres


# --- Database Connection Configuration ---

# The connection URL: Includes the sub-protocol (jdbc), the database type (postgresql), 
# the host/port (localhost:5432), and the specific database name (iam_db).
# spring.datasource.url=jdbc:postgresql://localhost:5432/iam_db

# The database user account that Spring will use to authenticate.
# spring.datasource.username=user

# The password associated with the database user defined above.
# spring.datasource.password=password

# The fully qualified name of the JDBC driver class. 
# Note: In modern Spring Boot versions, this is often optional as Spring can 
# usually "guess" the driver based on the URL.
# spring.datasource.driver-class-name=org.postgresql.Driver

# Prevents the app from crashing if the Docker container is still 
# performing its internal 'initdb' scripts during the first few seconds.
spring.datasource.hikari.initialization-fail-timeout=0


# --- JPA / Hibernate Settings ---

# Determines the Data Definition Language (DDL) behavior on startup.
# 
# 1. "update": (BEST FOR DEV) Compares the @Entity classes with the DB schema. 
#    - It will automatically create missing tables or add missing columns. 
#    - It never deletes/drops columns to prevent accidental data loss.
#
# 2. "validate": (BEST FOR PROD) Strictly compares Java entities to the DB.
#    - It makes zero changes to the database.
#    - If there is a mismatch, the application will crash on startup.
#    - This ensures your Flyway/Liquibase scripts have been executed correctly.
#
# 3. "create/create-drop": Drops everything and recreates it. (BEST FOR TESTS).
#
spring.jpa.hibernate.ddl-auto=none

# When set to true, Hibernate will log every SQL statement it executes to the console.
# Extremely helpful for debugging and seeing what Hibernate is doing "under the hood."
spring.jpa.show-sql=true

# Improves readability by formatting the logged SQL statements into a multi-line, 
# indented structure rather than a single long line.
spring.jpa.properties.hibernate.format_sql=true

# Force Hibernate to wait until Flyway is finished
spring.jpa.properties.hibernate.validator.apply_to_ddl=false

# --- Migration Tool Settings ---

# Disables Flyway's automatic migration on startup. 
# Once you have your SQL scripts ready in 'src/main/resources/db/migration', 
# set this to 'true' and change 'ddl-auto' to 'validate'.
spring.flyway.enabled=true